#!/usr/bin/env python
# -*- coding: latin-1 -*-
#
#   Copyright 2016-2019 Blaise Frederick
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
# $Author: frederic $
#       $Date: 2016/07/11 14:50:43 $
#       $Id: showtc,v 1.16 2016/07/11 14:50:43 frederic Exp $
#
from __future__ import print_function
import sys
import os
import getopt
import rapidtide.io as tide_io
import rapidtide.filter as tide_filt
import numpy as np
from scipy import fftpack, linspace


def usage():
    print("filttc - filter the data in text files")
    print("")
    print("usage: filttc inputfile[:col1,col2...,coln] outputfile")
    print("")
    print("required arguments:")
    print(
        "    inputfile               - a text file containing whitespace separated timecourses, one timepoint per"
    )
    print(
        "                              line. A list of comma separated numbers following the filename and preceded"
    )
    print("                              by a colon is used to select columns to plot")
    print(
        "    outputfile	           - The name of the text file in which to store the filtered data"
    )
    print("")
    print("optional arguments:")
    print(
        "    --samplerate=Fs         - the sample rate of the input data is Fs Hz (default is 1Hz)"
    )
    print(
        "    --sampletime=Ts         - the sample time (1/samplerate) of the input data is Ts seconds (default is 1s)"
    )
    print(
        "    -F                      - Filter data and regressors from LOWERFREQ to UPPERFREQ."
    )
    print(
        "                              LOWERSTOP and UPPERSTOP can be specified, or will be"
    )
    print("                              calculated automatically")
    print("    -V                      - Filter data and regressors to VLF band")
    print("    -L                      - Filter data and regressors to LFO band")
    print(
        "    -R                      - Filter data and regressors to respiratory band"
    )
    print("    -C                      - Filter data and regressors to cardiac band")
    print("    --padtime=PAD           - End pad in seconds (default is 30)")
    print("    --debug                 - print debugging information")
    return ()


def main():
    # set default variable values
    debug = False
    filtertype = None
    padtime = 30.0
    thefilter = tide_filt.noncausalfilter(padtime=padtime)
    detrendorder = 0
    dotranspose = False

    # get the command line parameters
    try:
        opts, args = getopt.gnu_getopt(
            sys.argv,
            "F:VLRC",
            ["help", "debug", "samplerate=", "sampletime=", "padtime="],
        )
    except getopt.GetoptError as err:
        # print help information and exit:
        print(str(err))  # will print something like 'option -a not recognized'
        usage()
        sys.exit(2)

    # check for filename arguments
    nargs = len(args)
    if nargs != 3:
        usage()
        sys.exit(1)

    # now parse options
    for o, a in opts:
        linkchar = " "
        if o == "--samplerate":
            samplerate = float(a)
            linkchar = "="
            print("Samplerate set to ", samplerate)
        elif o == "--sampletime":
            samplerate = 1.0 / float(a)
            linkchar = "="
            print("Samplerate set to ", samplerate)
        elif o == "--padtime":
            padtime = float(a)
            thefilter.setpadtime(padtime)
            linkchar = "="
            print("Pad time set to ", padtime)
        elif o == "-V":
            filtertype = "vlf"
            thefilter.settype(filtertype)
            if debug:
                print("filtering to vlf band")
        elif o == "-L":
            filtertype = "lfo"
            thefilter.settype(filtertype)
            if debug:
                print("filtering to lfo band")
        elif o == "-R":
            filtertype = "resp"
            thefilter.settype(filtertype)
            if debug:
                print("filtering to respiratory band")
        elif o == "-C":
            filtertype = "cardiac"
            thefilter.settype(filtertype)
            if debug:
                print("filtering to cardiac band")
        elif o == "-F":
            filtertype = "arb"
            thefilter.settype(filtertype)
            arbvec = a.split(",")
            if len(arbvec) != 2 and len(arbvec) != 4:
                usage()
                sys.exit()
            if len(arbvec) == 2:
                arb_lower = float(arbvec[0])
                arb_upper = float(arbvec[1])
                arb_lowerstop = 0.9 * float(arbvec[0])
                arb_upperstop = 1.1 * float(arbvec[1])
            if len(arbvec) == 4:
                arb_lower = float(arbvec[0])
                arb_upper = float(arbvec[1])
                arb_lowerstop = float(arbvec[2])
                arb_upperstop = float(arbvec[3])
            thefilter.setfreqs(arb_lowerstop, arb_lower, arb_upper, arb_upperstop)
            if debug:
                print(
                    "filtering to ",
                    arb_lower,
                    arb_upper,
                    "(stops at ",
                    arb_lowerstop,
                    arb_upperstop,
                    ")",
                )
        elif o in ("-h", "--help"):
            usage()
            sys.exit()
        else:
            assert False, "unhandled option:" + o

    if filtertype is None:
        print("you must select a filter type")
        sys.exit()

    # handle required args first
    xvecs = []
    yvecs = []
    linelabels = []
    samplerates = []
    numfiles = 1
    numvecs = 0
    textfilename = args[1].split(":")
    outputfile = args[2]

    shortcolnames = True
    # read in all the data

    # check file type
    filebase, extension = os.path.splitext(textfilename[0])
    if extension == ".json":
        (
            thissamplerate,
            thisstartoffset,
            colnames,
            invecs,
            compressed,
        ) = tide_io.readbidstsv(textfilename[0])
    else:
        invecs = tide_io.readvecs(textfilename[0])
        thissamplerate = samplerate
        thisstartoffset = 0.0
        colnames = None
    if dotranspose:
        invecs = np.transpose(invecs)
    if debug:
        print("   ", invecs.shape[0], " columns")
    if len(textfilename) == 2:
        collist = []
        for column in (textfilename[1]).split(","):
            collist.append(int(column))
    else:
        collist = range(0, invecs.shape[0])

    minlen = 100000000
    for j in collist:
        if debug:
            print("appending vector number ", j)
        yvecs.append(invecs[j] * 1.0)
        if len(yvecs[-1]) < minlen:
            minlen = len(yvecs[-1])
        samplerates.append(thissamplerate + 0.0)
        numvecs += 1

    outvecs = np.zeros((numvecs, minlen), dtype=float)
    for i in range(numvecs):
        outvecs[:] = thefilter.apply(samplerate, yvecs[i][:minlen])

    tide_io.writenpvecs(outvecs, outputfile)


if __name__ == "__main__":
    main()
