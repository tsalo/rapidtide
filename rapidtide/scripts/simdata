#!/usr/bin/env python
# -*- coding: latin-1 -*-
#
#   Copyright 2016-2019 Blaise Frederick
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
#       $Author: frederic $
#       $Date: 2016/06/14 12:04:51 $
#       $Id: simdata,v 1.18 2016/06/14 12:04:51 frederic Exp $
#
from __future__ import print_function
import rapidtide.miscmath as tide_math
import getopt
import rapidtide.io as tide_io
import rapidtide.resample as tide_resample
from matplotlib.pyplot import *
import scipy as sp
import numpy as np


def prepareband(
    fmridims,
    pctfile,
    lagfile,
    regressorfile,
    samprate,
    starttime,
    regressorname,
    padtime=30.0,
):
    # read in the timecourse to resample
    rawvec = tide_math.stdnormalize(tide_io.readvec(regressorfile))
    regressorpts = len(rawvec)

    print("Input regressor has ", regressorpts, " points")
    regressor_x = (
        sp.linspace(
            0.0, (1.0 / samprate) * regressorpts, num=regressorpts, endpoint=False
        )
        - starttime
    )
    regressor_y = rawvec[0:regressorpts]
    print(
        regressorname,
        "regressor has length",
        len(regressor_x),
        "and runs from ",
        regressor_x[0],
        " to ",
        regressor_x[-1],
    )

    nim_pct, pctdata, pctheader, pctdims, pctsizes = tide_io.readfromnifti(pctfile)
    if not tide_io.checkspacedimmatch(pctdims, fmridims):
        print(regressorname, "pct file does not match fmri")
        exit()
    nim_lag, lagdata, lagheader, lagdims, lagsizes = tide_io.readfromnifti(lagfile)
    if not tide_io.checkspacedimmatch(lagdims, fmridims):
        print(regressorname, "lag file does not match fmri")
        exit()

    generator = tide_resample.fastresampler(
        regressor_x, regressor_y, padtime=padtime, doplot=False
    )
    return pctdata, lagdata, generator


def fmrisignal(
    times,
    meanvalue,
    dolfo=False,
    lfowave=None,
    lfomag=None,
    lfodelay=None,
    doresp=False,
    respwave=None,
    respmag=None,
    respdelay=None,
    docardiac=False,
    cardiacwave=None,
    cardiacmag=None,
    cardiacdelay=None,
):

    thesignal = np.zeros((len(times)), dtype=np.float)
    if dolfo:
        thesignal += meanvalue * (lfomag / 100.0) * lfowave.yfromx(times + lfodelay)
    if doresp:
        thesignal += meanvalue * (respmag / 100.0) * respwave.yfromx(times + respdelay)
    if docardiac:
        thesignal += (
            meanvalue * (cardiacmag / 100.0) * cardiacwave.yfromx(times + cardiacdelay)
        )
    return thesignal + meanvalue


def usage():
    print(
        "usage: simdata fmrifilename immeanfilename outputname slicetimefile=FILENAME lagfilename regressor regressorsamprate numskip inputstarttime outputname noiselevel sliceorder"
    )
    print("")
    print("required arguments:")
    print("	fmrifilename                - the example BOLD fmri file")
    print("	immeanfilename              - the 3D mean image file")
    print("	outputname                  - the root name for the output files")
    print(
        "	slicetimefile               - slice acquisition time file, either FSL format or BIDS sidecar"
    )

    print("")
    print(
        "variable arguments (at least one set of parameters - LFO, respiratory, or cardiac - must be specified):"
    )
    print(
        "	lfopctfile=FILENAME         - NIFTI file with the lfo amplitude in percent of mean at every point"
    )
    print(
        "	lfolagfile=FILENAME         - NIFTI file with the lfo delay value in seconds at every point"
    )
    print("	lforegressor=FILENAME       - the name of the LFO regressor text file")
    print(
        "	lfosamprate=FREQ            - the sample rate of the LFO regressor file, in Hz"
    )
    print(
        "	lfostarttime=TIME           - the time delay, in seconds, into the LFO regressor file that matches the start time of the fmrifile. Default is 0"
    )
    print(
        "	resppctfile=FILENAME        - NIFTI file with the resp amplitude in percent of mean at every point"
    )
    print(
        "	resplagfile=FILENAME        - NIFTI file with the resp delay value in seconds at every point"
    )
    print(
        "	respregressor=FILENAME      - the name of the respiratory regressor text file"
    )
    print(
        "	respsamprate=FREQ           - the sample rate of the respiratory regressor file, in Hz"
    )
    print(
        "	respstarttime=TIME          - the time delay, in seconds, into the respiratory regressor file that matches the start time of the fmrifile. Default is 0"
    )
    print(
        "	cardiacpctfile=FILENAME     - NIFTI file with the cardiac amplitude in percent of mean at every point"
    )
    print(
        "	cardiaclagfile=FILENAME     - NIFTI file with the cardiac delay value in seconds at every point"
    )
    print("	cardiacregressor=FILENAME   - the name of the cardiac regressor text file")
    print(
        "	cardiacsamprate=FREQ        - the sample rate of the cardiac regressor file, in Hz"
    )
    print(
        "	cardiacstarttime=TIME       - the time delay, in seconds, into the LFO regressor file that matches the start time of the fmrifile. Default is 0"
    )
    print("")
    print("optional arguments:")
    print(
        "	numskip=SKIP                - use to simulate tr periods deleted during preprocessing"
    )
    print("	noiselevel=LEVEL            - the variance of the noise.  Default is 0.0")
    """print("					0 : None")
    print("					1 : Regular up (0, 1, 2, 3, ...)")
    print("					2 : Regular down")
    print("					3 : Use slice order file")
    print("					4 : Use slice timings file")
    print("					5 : Standard Interleaved (0, 2, 4 ... 1, 3, 5 ... )")
    print("					6 : Siemens Interleaved (0, 2, 4 ... 1, 3, 5 ... for odd number of slices)")
    print("					                        (1, 3, 5 ... 0, 2, 4 ... for even number of slices)")"""

    return ()


def simdata_main(thearguments):
    # set default variable values
    displayplots = False
    fastresample = True
    debug = False

    # handle required args first
    fmrifilename = None
    immeanfilename = None

    lfopctfile = None
    lfolagfile = None
    lfopctdata = None
    lfolagdata = None
    lforegressor = None
    lfosamprate = None
    lfostarttime = 0.0
    lfogenerator = None

    resppctfile = None
    resplagfile = None
    resppctdata = None
    resplagdata = None
    respregressor = None
    respsamprate = None
    respstarttime = 0.0
    respgenerator = None

    cardiacpctfile = None
    cardiaclagfile = None
    cardiacctdata = None
    cardiaclagdata = None
    cardiacregressor = None
    cardiacsamprate = None
    cardiacstarttime = 0.0
    cardiacgenerator = None

    noiselevel = 0.0
    numskip = 0

    #  scan for  arguments
    reqnum = 8
    if len(thearguments) < reqnum - 1:
        print(
            "Not enough arguments specified - got",
            len(thearguments) - 1,
            "expected",
            reqnum,
            " - exiting.",
        )
        usage()
        sys.exit()

    fmrifilename = thearguments[1]
    immeanfilename = thearguments[2]
    outputname = thearguments[3]
    slicetimefile = thearguments[4]

    optparsestart = 5
    print(thearguments[optparsestart:])
    try:
        opts, args = getopt.getopt(
            thearguments[optparsestart:],
            "x",
            [
                "help",
                "lfopctfile=",
                "lfolagfile=",
                "lforegressor=",
                "lfosamprate=",
                "lfostarttime=",
                "resppctfile=",
                "resplagfile=",
                "respregressor=",
                "respsamprate=",
                "respstarttime=",
                "cardiacpctfile=",
                "cardiaclagfile=",
                "cardiacregressor=",
                "cardiacsamprate=",
                "cardiacstarttime=",
                "noiselevel=",
                "numskip=",
            ],
        )
    except getopt.GetoptError as err:
        # print help information and exit:
        print(str(err))  # will print something like "option -x not recognized"
        usage()
        sys.exit(2)

    formattedcmdline = [thearguments[0] + " \\"]
    for thearg in range(1, optparsestart):
        formattedcmdline.append("\t" + thearguments[thearg] + " \\")

    for o, a in opts:
        linkchar = "="
        if o == "-x":
            print("Got an x")
        elif o == "--lfopctfile":
            lfopctfile = a
            print("Using", lfopctfile, "as LFO percentage file")
        elif o == "--lfolagfile":
            lfolagfile = a
            print("Using", lfolagfile, "as LFO lag file")
        elif o == "--lforegressor":
            lforegressor = a
            print("Using", lforegressor, "as LFO regressor file")
        elif o == "--lfosamprate":
            lfosamprate = float(a)
            print("Using", lfosamprate, "as LFO regressor sample rate")
        elif o == "--lfosamprate":
            lfosamprate = float(a)
            print("Using", lfosamptime, "as LFO regressor samplerate")

        elif o == "--resppctfile":
            resppctfile = a
            print("Using", resppctfile, "as respiratory percentage file")
        elif o == "--resplagfile":
            resplagfile = a
            print("Using", resplagfile, "as respiratory lag file")
        elif o == "--respregressor":
            respregressor = a
            print("Using", respregressor, "as respiratory regressor file")
        elif o == "--respsamprate":
            respsamprate = float(a)
            print("Using", respsamprate, "as respiratory regressor sample rate")
        elif o == "--respsamprate":
            respsamprate = float(a)
            print("Using", respsamptime, "as respiratory regressor samplerate")

        elif o == "--cardiacpctfile":
            cardiacpctfile = a
            print("Using", cardiacpctfile, "as cardiac percentage file")
        elif o == "--cardiaclagfile":
            cardiaclagfile = a
            print("Using", cardiaclagfile, "as cardiac lag file")
        elif o == "--cardiacregressor":
            cardiacregressor = a
            print("Using", cardiacregressor, "as cardiac regressor file")
        elif o == "--cardiacsamprate":
            cardiacsamprate = float(a)
            print("Using", cardiacsamprate, "as cardiac regressor sample rate")
        elif o == "--cardiacsamprate":
            cardiacsamprate = float(a)
            print("Using", cardiacsamptime, "as cardiac regressor samplerate")

        elif o == "--noiselevel":
            noiselevel = float(a)
            print("Noise level set to", noiselevel)
        elif o == "--numskip":
            numskip = int(a)
            print("Numskip set to", numskip)

        else:
            assert False, "unhandled option: " + o
        formattedcmdline.append("\t" + o + linkchar + a + " \\")

    # check for complete information
    if (
        (lfopctfile is None)
        or (lfolagfile is None)
        or (lforegressor is None)
        or (lfosamprate is None)
    ):
        print("lfopctfile:", lfopctfile)
        print("lfolagfile:", lfolagfile)
        print("lforegressor:", lforegressor)
        print("lfopctsamprate:", lfosamprate)
        dolfo = False
    else:
        dolfo = True
        print("LFO information is complete, will be included.")

    if (
        (resppctfile is None)
        or (resplagfile is None)
        or (respregressor is None)
        or (respsamprate is None)
    ):
        doresp = False
    else:
        doresp = True
        print("Respiratory information is complete, will be included.")

    if (
        (cardiacpctfile is None)
        or (cardiaclagfile is None)
        or (cardiacregressor is None)
        or (cardiacsamprate is None)
    ):
        docardiac = False
    else:
        docardiac = True
        print("Cardiac information is complete, will be included.")
    if not (dolfo or doresp or docardiac):
        print(
            "Must specify parameters for at least one of LFO, respiration, or cardiac signals - exiting"
        )
        usage()
        sys.exit()

    sliceoffsettimes = tide_io.getslicetimesfromfile(slicetimefile)

    fmritr, numtrs = tide_io.fmritimeinfo(fmrifilename)
    nim_fmri, fmridata, fmriheader, fmridims, fmrisizes = tide_io.readfromnifti(
        fmrifilename
    )
    print("fmri data: ", numtrs, " timepoints, tr = ", fmritr)

    # prepare the output timepoints
    initial_fmri_x = (
        sp.linspace(
            0.0, fmritr * (numtrs - numskip), num=(numtrs - numskip), endpoint=False
        )
        + fmritr * numskip
    )
    print("length of fmri after removing skip:", len(initial_fmri_x))
    print(
        "fmri time has length",
        len(initial_fmri_x),
        "and runs runs from ",
        initial_fmri_x[0],
        " to ",
        initial_fmri_x[-1],
    )

    # read in the immean file
    print("reading in source files")
    (
        nim_immean,
        immeandata,
        immeanheader,
        immeandims,
        immeansizes,
    ) = tide_io.readfromnifti(immeanfilename)
    if not tide_io.checkspacedimmatch(immeandims, fmridims):
        print("immean file does not match")
        exit()

    # now set up the simulated data array
    thedims = fmridims
    xsize = thedims[1]
    ysize = thedims[2]
    numslices = thedims[3]
    simdata = np.zeros((xsize, ysize, numslices, len(initial_fmri_x)), dtype="float")

    # set up fast resampling
    padtime = 60.0
    numpadtrs = int(padtime / fmritr)
    padtime = fmritr * numpadtrs

    # prepare the input data for interpolation
    if dolfo:
        lfopctdata, lfolagdata, lfogenerator = prepareband(
            fmridims,
            lfopctfile,
            lfolagfile,
            lforegressor,
            lfosamprate,
            lfostarttime,
            "LFO",
            padtime=padtime,
        )
    if doresp:
        resppctdata, resplagdata, respgenerator = prepareband(
            fmridims,
            resppctfile,
            resplagfile,
            respregressor,
            respsamprate,
            respstarttime,
            "respiratory",
            padtime=padtime,
        )
    if docardiac:
        cardiacpctdata, cardiaclagdata, cardiacgenerator = prepareband(
            fmridims,
            cardiacpctfile,
            cardiaclagfile,
            cardiacregressor,
            cardiacsamprate,
            cardiacstarttime,
            "cardiac",
            padtime=padtime,
        )

    # loop over space
    for k in range(0, numslices):
        fmri_x_slice = initial_fmri_x - sliceoffsettimes[k]
        print("processing slice ", k, ": sliceoffsettime=", sliceoffsettimes[k])
        for j in range(0, ysize):
            for i in range(0, xsize):
                # generate the noise
                thenoise = noiselevel * np.random.standard_normal(len(initial_fmri_x))

                # add in the signals
                if dolfo:
                    lfopct = lfopctdata[i, j, k]
                    lfolag = lfolagdata[i, j, k]
                else:
                    lfopct = 0.0
                    lfolag = 0.0
                if doresp:
                    resppct = resppctdata[i, j, k]
                    resplag = resplagdata[i, j, k]
                else:
                    resppct = 0.0
                    resplag = 0.0
                if docardiac:
                    cardiacpct = cardiacpctdata[i, j, k]
                    cardiaclag = cardiaclagdata[i, j, k]
                else:
                    cardiacpct = 0.0
                    cardiaclag = 0.0

                simdata[i, j, k, :] = (
                    fmrisignal(
                        fmri_x_slice,
                        immeandata[i, j, k],
                        dolfo=dolfo,
                        lfowave=lfogenerator,
                        lfomag=lfopct,
                        lfodelay=lfolag,
                        doresp=doresp,
                        respwave=respgenerator,
                        respmag=resppct,
                        respdelay=resplag,
                        docardiac=docardiac,
                        cardiacwave=cardiacgenerator,
                        cardiacmag=cardiacpct,
                        cardiacdelay=cardiaclag,
                    )
                    + thenoise
                )

    tide_io.savetonifti(simdata, fmriheader, outputname)


if __name__ == "__main__":

    # grab the command line arguments then pass them off.
    simdata_main(sys.argv)
