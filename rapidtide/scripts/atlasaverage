#!/usr/bin/env python
# -*- coding: latin-1 -*-
#
#   Copyright 2016-2019 Blaise Frederick
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
#       $Author: frederic $
#       $Date: 2016/06/14 12:04:50 $
#       $Id: histnifti,v 1.8 2016/06/14 12:04:50 frederic Exp $
#
from __future__ import print_function
import sys
import getopt
import string
import rapidtide.io as tide_io
import rapidtide.miscmath as tide_math
from sklearn.cluster import KMeans, MiniBatchKMeans

import numpy as np


def summarize(thevoxels, method="mean"):
    theshape = thevoxels.shape
    if len(theshape) > 1:
        numtimepoints = theshape[1]
    else:
        numtimepoints = 1

    if method == "mean":
        themethod = np.mean
    elif method == "median":
        themethod = np.median
    else:
        print("illegal summary method in summarize")
        sys.exit()
    if numtimepoints > 1:
        regionsummary = np.nan_to_num(themethod(thevoxels, axis=1))
    else:
        regionsummary = np.nan_to_num(themethod(thevoxels))
    return regionsummary


def usage():
    print(
        "usage: atlasaverage fmrifile templatefile outputfile [--stdnorm] [--pctnorm] [--ppnorm] [--varnorm] [--nonorm]"
    )
    print("")
    print("required arguments:")
    print(
        "    inputfile        - the name of the 3 or 4D nifti file with the data to be averaged over atlas regions"
    )
    print("    templatefile     - the name of the template region file")
    print("    outputfile       - the name of the output text file")
    print("")
    print("optional arguments:")
    print("    --nonorm         - don't normalize timecourses (default)")
    print(
        "    --pctnorm        - scale each timecourse to it's percentage of the mean over time"
    )
    print(
        "    --varnorm        - scale each timecourse to have a variance over time of 1.0"
    )
    print(
        "    --stdnorm        - scale each timecourse to have a standard deviation over time of 1.0"
    )
    print(
        "    --ppnorm         - scale each timecourse to have a peak to peak range over time of 1.0"
    )
    print(
        "    --mean           - calculate the mean over each spatial region (default)"
    )
    print(
        "    --nzmean         - calculate the mean over nonzero values in each spatial region"
    )
    print(
        "    --mad            - calculate the median average deviate over each spatial region"
    )
    print(
        "    --nzmad          - calculate the median average deviate over nonzero values in each spatial region"
    )
    print("")
    return ()


def main():
    # get the command line parameters
    if len(sys.argv) < 4:
        usage()
        exit()

    # handle required args first
    inputfilename = sys.argv[1]
    templatefile = sys.argv[2]
    outputfile = sys.argv[3]

    normmethod = "None"
    summarymethod = "mean"

    # now scan for optional arguments
    try:
        opts, args = getopt.getopt(
            sys.argv[4:],
            "h",
            ["nonorm", "pctnorm", "varnorm", "stdnorm", "ppnorm", "help"],
        )
    except getopt.GetoptError as err:
        # print help information and exit:
        print(str(err))  # will print something like "option -x not recognized"
        usage()
        sys.exit(2)

    for o, a in opts:
        if o == "--nonorm":
            normmethod = "None"
        elif o == "--pctnorm":
            normmethod = "pctnorm"
        elif o == "--stdnorm":
            normmethod = "stdnorm"
        elif o == "--varnorm":
            normmethod = "varnorm"
        elif o == "--ppnorm":
            normmethod = "ppnorm"
        elif o == "-h" or o == "--help":
            usage()
            exit()
        else:
            assert False, "unhandled option"

    if normmethod == "None":
        print("will not normalize timecourses")
    elif normmethod == "pctnorm":
        print("will normalize timecourses to percentage of mean")
    elif normmethod == "stdnorm":
        print("will normalize timecourses to standard deviation of 1.0")
    elif normmethod == "varnorm":
        print("will normalize timecourses to variance of 1.0")
    elif normmethod == "ppnorm":
        print("will normalize timecourses to p-p deviation of 1.0")

    print("loading fmri data")
    input_img, input_data, input_hdr, thedims, thesizes = tide_io.readfromnifti(
        inputfilename
    )
    print("loading template data")
    (
        template_img,
        template_data,
        template_hdr,
        templatedims,
        templatesizes,
    ) = tide_io.readfromnifti(templatefile)

    print("checking dimensions")
    if not tide_io.checkspacematch(input_hdr, template_hdr):
        print("template file does not match spatial coverage of input fmri file")
        sys.exit()

    print("reshaping")
    xsize = thedims[1]
    ysize = thedims[2]
    numslices = thedims[3]
    numtimepoints = thedims[4]
    numvoxels = int(xsize) * int(ysize) * int(numslices)
    templatevoxels = np.reshape(template_data, numvoxels).astype(int)
    inputvoxels = np.reshape(input_data, (numvoxels, numtimepoints))
    numregions = np.max(templatevoxels)
    timecourses = np.zeros((numregions, numtimepoints), dtype="float")

    if numtimepoints > 1:
        for theregion in range(1, numregions + 1):
            thevoxels = inputvoxels[np.where(templatevoxels == theregion), :]
            print(
                "extracting",
                thevoxels.shape[1],
                "voxels from region",
                theregion,
                "of",
                numregions,
            )
            if thevoxels.shape[1] > 0:
                # regiontimecourse = np.nan_to_num(np.mean(thevoxels, axis=1))
                regiontimecourse = summarize(thevoxels, method=summarymethod)
            else:
                regiontimecourse = timecourses[0, :] * 0.0
            if normmethod == "None":
                timecourses[theregion - 1, :] = regiontimecourse - np.mean(
                    regiontimecourse
                )
            elif normmethod == "pctnorm":
                timecourses[theregion - 1, :] = tide_math.pcnormalize(regiontimecourse)
            elif normmethod == "varnorm":
                timecourses[theregion - 1, :] = tide_math.varnormalize(regiontimecourse)
            elif normmethod == "stdnorm":
                timecourses[theregion - 1, :] = tide_math.stdnormalize(regiontimecourse)
            elif normmethod == "ppnorm":
                timecourses[theregion - 1, :] = tide_math.ppnormalize(regiontimecourse)
            else:
                print("illegal normalization method")
                usage()
                sys.exit()
        tide_io.writenpvecs(timecourses, outputfile)
    else:
        outputvoxels = np.reshape(input_data, (numvoxels, numtimepoints))
        for theregion in range(1, numregions + 1):
            thevoxels = inputvoxels[np.where(templatevoxels == theregion)]
            # regionval = np.nan_to_num(np.mean(thevoxels))
            regionval = summarize(thevoxels, method=summarymethod)
            outputvoxels[np.where(templatevoxels == theregion)] = regionval
        template_hdr["dim"][4] = numregions
        tide_io.savetonifti(
            outputvoxels.reshape((xsize, ysize, numslices, numregions)),
            template_hdr,
            outputfile,
        )


if __name__ == "__main__":
    main()
