#!/usr/bin/env python
#
#   Copyright 2016 Blaise Frederick
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
# $Author: frederic $
#       $Date: 2016/07/11 14:50:43 $
#       $Id: showxcorr,v 1.41 2016/07/11 14:50:43 frederic Exp $
#
from __future__ import print_function, division

import time
import sys
import os
import platform

import numpy as np
import scipy as sp
# import gc

import getopt
import rapidtide.miscmath as tide_math
import rapidtide.stats as tide_stats
import rapidtide.util as tide_util
import rapidtide.io as tide_io
import rapidtide.filter as tide_filt
import rapidtide.fit as tide_fit
import rapidtide.resample as tide_resample
import rapidtide.correlate as tide_corr
import rapidtide.multiproc as tide_multiproc
import rapidtide.glmpass as tide_glmpass
from scipy.signal import hilbert, welch, savgol_filter

from matplotlib.pyplot import plot, show, figure

try:
    import mkl

    mklexists = True
except ImportError:
    mklexists = False


def _procOneVoxelNormalize(vox, voxels):
    if detrend:
        normtc = tide_math.pcnormalize(tide_fit.detrend(voxels[vox, :], demean=False))
    else:
        normtc = tide_math.pcnormalize(voxels[vox, :])
    return vox, normtc


def tcnorm(validimbyvox, nprocs=1, detrend=False):
    """

    Parameters
    ----------
    validimbyvox : 4D numpy array
    nprocs : int, optional
    detrend : bool, optional

    Returns
    -------
    normvoxels : 4D numpy array

    """
    inputshape = np.shape(validimbyvox)
    print(inputshape)
    normvoxels = validimbyvox * 0.0
    volumetotal = 0
    reportstep = 1000
    if nprocs > 1:
        # define the consumer function here so it inherits most of the arguments
        def normalize_consumer(inQ, outQ):
            while True:
                try:
                    # get a new message
                    val = inQ.get()

                    # this is the 'TERM' signal
                    if val is None:
                        break

                    # process and send the data
                    outQ.put(_procOneVoxelNormalize(val, validimbyvox))

                except Exception as e:
                    print("error!", e)
                    break

        data_out = tide_multiproc.run_multiproc(normalize_consumer,
                                                inputshape, None,
                                                nprocs=nprocs,
                                                showprogressbar=True,
                                                chunksize=10000)

        # unpack the data
        volumetotal = 0
        for voxel in data_out:
            normvoxels[voxel[0], :] = voxel[1]
            volumetotal += 1
        del data_out
    else:
        for vox in range(0, inputshape[0]):
            if (vox % reportstep == 0 or vox == inputshape[0] - 1):
                tide_util.progressbar(vox + 1, inputshape[0], label='Percent complete')
            dummy, normvoxels[vox, :] = _procOneVoxelNormalize(vox, validimbyvox)
            volumetotal += 1
    print('\nNormalization performed on ' + str(volumetotal) + ' voxels')

    # garbage collect
    # collected = gc.collect()
    # print("Garbage collector: collected %d objects." % collected)

    return volumetotal, normvoxels


def usage():
    print(os.path.basename(sys.argv[0]), "- Hypersampling by Analytic Phase Projection - Yay!")
    print("")
    print("usage: ", os.path.basename(sys.argv[0]), " fmrifile slicetimefile outputroot")
    print("")
    print("required arguments:")
    print("    fmrifile:                 nifti file containing BOLD fmri data")
    print("    slicetimefile:            text file containing the offset time in seconds of each slice relative to the start of the TR,")
    print("                              one value per line, OR the BIDS sidecar JSON file for the fmrifile (contains the SliceTiming field")
    print("    outputroot:               base name for all output files")
    print("")
    print("optional arguments:")
    print("    --glm                      - generate voxelwise aliased synthetic cardiac regressors and filter them out")
    print("    --minhr=MINHR              - highpass filter cardiac data to MINHR BPM (default is 180.0)")
    print("    --maxhr=MAXHR              - lowpass filter cardiac data to MAXHR BPM (default is 36.0)")
    print( "    --notchwidth=WIDTH         - Set the width of the notch filter, in percent of the notch frequency (default is 1.5)")
    print("    --outputbins=BINS          - number of output phase bins (default is 32)")
    print("    --gridbins=BINS            - width of the gridding kernel in output phase bins (default is 1.5)")
    print("    --cardiacfile=FILE[:COL]   - Read the cardiac waveform from file FILE.  If COL is an integer,")

    print("                                 format json file, use column named COL (if no file is specified ")
    print("                                 is specified, estimate cardiac signal from data)")
    print("    --cardiacfreq=FREQ         - Cardiac waveform in cardiacfile has sample frequency FREQ ")
    print("                                 (default is 32Hz). NB: --cardiacfreq and --cardiactstep")
    print("                                 are two ways to specify the same thing")
    print("    --cardiactstep=TSTEP       - Cardiac waveform in file has sample time step TSTEP ")
    print("                                 (default is 0.03125s) NB: --cardiacfreq and --cardiactstep")
    print("                                 are two ways to specify the same thing")
    print("    --cardiacstart=START       - The time delay in seconds into the cardiac file, corresponding")
    print("                                 in the first TR of the fmri file (default is 0.0)")
    print("    --stdfreq=FREQ             - Frequency to which the cardiac signals are resampled for output.  Default")
    print("                                 is 25.")
    print("    --forcehr=BPM              - Force heart rate fundamental detector to be centered at BPM (overrides peak:)"
          "                                 frequencies found from spectrum.  Useful if there is structured noise")
    #print(
    #    "    --nprocs=NPROCS            - Set to number of processors to use for calculations.  Default is 1.  Setting negative will use ncpus - 1")
    print("")
    print("debugging arguments (probably not of interest to users)")
    print("    --debug                    - turn on debugging information")
    print("    --nodetrend                - disable data detrending")
    print("    --normalize                - normalize fmri data")
    print("    --disablenotch             - disable subharmonic notch filter")

    return ()


def phasemod(phase):
    """

    Parameters
    ----------
    phase : array-like
        An unwrapped phase vector

    Returns
    -------
    wrapped : array-like
        The phase vector, remapped to the range of +/-np.pi
    """
    return np.fmod(np.pi + phase, 2.0 * np.pi) - np.pi


def rrifromphase(timeaxis, thephase):
    return None


def setnotchfilter(thefilter, thefreq, notchwidth=0.01):
    thefilter.settype('arb_stop')
    thefilter.setarb(
        thefreq * (1.0 - notchwidth / 2.0),
        thefreq * (1.0 - notchwidth / 2.0),
        thefreq * (1.0 + notchwidth / 2.0),
        thefreq * (1.0 + notchwidth / 2.0))


def cardiacsig(thisphase, amps=[1.0, 0.0, 0.0], phases=None, overallphase=0.0):
    total = 0.0
    if phases is None:
        phases = amps * 0.0
    for i in range(len(amps)):
        total += amps[i] * np.cos((i + 1) * thisphase + phases[i] + overallphase)
    return total


def getslicetimesfromfile(slicetimename):
    filebase, extension = os.path.splitext(slicetimename)
    if extension == '.json':
        jsoninfodict = tide_io.readbidssidecar(slicetimename)
        try:
            slicetimelist = jsoninfodict['SliceTiming']
            slicetimes = np.zeros((len(slicetimelist)), dtype=np.float64)
            for idx, thetime in enumerate(slicetimelist):
                slicetimes[idx] = float(thetime)
        except KeyError:
            print(slicetimename, 'is not a valid BIDS sidecar file')
            sys.exit()
    else:
        slicetimes = tide_io.readvec(slicetimename)
    return slicetimes


def cardiacfromimage(normdata_byslice,
                     mask_byslice,
                     numslices,
                     timepoints,
                     tr,
                     slicetimes,
                     initprefilter,
                     notchwidth=0.015,
                     offsetbyvox=None,
                     detrend=True,
                     nprocs=1,
                     debug=False):

    # find out what timepoints we have, and their spacing
    sortedtimes = np.sort(slicetimes)
    diffs = sortedtimes[1:] - sortedtimes[0:-1]
    minstep = np.max(diffs)
    numsteps = int(np.round(tr / minstep, 0))
    sliceoffsets = np.around(slicetimes / minstep).astype(np.int32) % numsteps
    print(len(slicetimes), 'slice times with', numsteps, 'unique values - diff is', minstep)

    # make slice means
    print('making slice means...')
    hirestc = np.zeros((timepoints * numsteps), dtype=np.float64)
    sliceavs = np.zeros((numslices, timepoints), dtype=np.float64)
    for theslice in range(numslices):
        print('averaging slice', theslice)
        validvoxels = np.where(mask_byslice[:, theslice] > 0)[0]
        if len(validvoxels) > 0:
            sliceavs[theslice, :] = np.mean(normdata_byslice[validvoxels, theslice, :], axis=0)
            for t in range(timepoints):
                hirestc[numsteps * t + sliceoffsets[theslice]] += sliceavs[theslice, t]
    slicesamplerate = 1.0 * numsteps / tr
    print('slice sample rate is ', slicesamplerate)
    filthirestc = -1.0 * tide_math.corrnormalize(initprefilter.apply(slicesamplerate, hirestc), False, False)

    # delete the TR frequency and the first subharmonic
    print('notch filtering...')
    maxpass = np.min([slicesamplerate / 2.0, initprefilter.getfreqlimits()[2]])
    if notchwidth > 0.0:
        stopfreq = 1.0 / tr
        maxharmonic = int(maxpass // stopfreq)
        print('highest harmonic is', maxharmonic, '(', maxharmonic * stopfreq, 'Hz)')
        trnotchfilter = tide_filt.noncausalfilter(debug=debug)
        for harmonic in range(1, maxharmonic + 1):
            print('removing harmonic at', harmonic * stopfreq)
            setnotchfilter(trnotchfilter, harmonic * stopfreq, notchwidth=notchwidth)
            filthirestc = trnotchfilter.apply(slicesamplerate, filthirestc)

    return filthirestc, slicesamplerate, numsteps


def phaseanalysis(firstharmonic):
    analytic_signal = hilbert(firstharmonic)
    amplitude_envelope = np.abs(analytic_signal)
    instantaneous_phase = np.angle(analytic_signal / amplitude_envelope)
    instantaneous_phase = np.unwrap(instantaneous_phase)
    return instantaneous_phase, amplitude_envelope


def savgolsmooth(data, smoothlen=301, polyorder=3):
    return savgol_filter(data, smoothlen, polyorder)


def getfundamental(inputdata, Fs, fundfreq):
    arb_lower = 0.71 * fundfreq
    arb_upper = 1.4 * fundfreq
    arb_lowerstop = 0.9 * arb_lower
    arb_upperstop = 1.1 * arb_upper
    thefundfilter = tide_filt.noncausalfilter(filtertype='arb')
    thefundfilter.setarb(arb_lowerstop, arb_lower, arb_upper, arb_upperstop)
    return thefundfilter.apply(Fs, inputdata)


def getcardcoeffs(cardiacwaveform, slicesamplerate, smoothlen=301, debug=False):
    if len(cardiacwaveform) > 1024:
        thex, they = welch(cardiacwaveform, slicesamplerate, nperseg=1024)
    else:
        thex, they = welch(cardiacwaveform, slicesamplerate)
    print('initpeakfreq:', np.round(thex[np.argmax(they)] * 60.0, 2), 'BPM')
    #spectrum = sp.fftpack.fft(tide_filt.hamming(len(cardiacwaveform)) * cardiacwaveform)[0:len(cardiacwaveform) // 2]
    freqaxis, spectrum = tide_filt.spectrum(tide_filt.hamming(len(cardiacwaveform)) * cardiacwaveform,
                                            Fs=slicesamplerate,
                                            mode='complex')
    smoothspectrum = savgolsmooth(spectrum.real, smoothlen=smoothlen) + savgolsmooth(spectrum.imag,
                                                                                     smoothlen=smoothlen) * 1.0j
    if debug:
        tide_io.writevec(spectrum.real, 'spectrum.txt')
        tide_io.writevec(smoothspectrum.real, 'smoothspectrum.txt')
    ampspec = np.abs(smoothspectrum)
    phasespec = np.angle(smoothspectrum)
    #maxfreq = slicesamplerate / 2.0
    #freqaxis = sp.linspace(0.0, maxfreq, len(ampspec), endpoint=False)
    if debug:
        figure()
        plot(freqaxis, ampspec, 'r')
        show()
    peakfreq = freqaxis[np.argmax(ampspec)]
    print('cardiac fundamental frequency is', np.round(peakfreq * 60.0, 2), 'BPM')
    normfac = np.sqrt(2.0) * tide_math.rms(cardiacwaveform)
    print('normfac:', normfac)
    amps = [normfac,
            normfac * ampspec[2 * np.argmax(ampspec)] / ampspec[np.argmax(ampspec)],
            normfac * ampspec[3 * np.argmax(ampspec)] / ampspec[np.argmax(ampspec)]]
    phases = [0.0,
              phasespec[2 * np.argmax(ampspec)] - phasespec[np.argmax(ampspec)],
              phasespec[3 * np.argmax(ampspec)] - phasespec[np.argmax(ampspec)]]
    return peakfreq, amps, phases


def cleanpleth(Fs, plethwaveform):
    # first bandpass the plethysmogram to calculate the envelope
    arb_lower = 0.5
    arb_lowerstop = arb_lower * 0.9
    arb_upper = 3.0
    arb_upperstop = arb_upper * 1.1
    plethfilter = tide_filt.noncausalfilter(filtertype='arb')
    plethfilter.setarb(arb_lowerstop, arb_lower, arb_upper, arb_upperstop)
    print('filtering')
    # filtplethwaveform = plethfilter.apply(Fs, tide_math.corrnormalize(plethwaveform, False, False))
    print('envelope detection')
    # envelope = tide_math.envdetect(Fs, filtplethwaveform, cutoff=0.15)
    envelope = tide_math.envdetect(Fs, plethfilter.apply(Fs, tide_math.corrnormalize(plethwaveform, False, False)),
                                   cutoff=0.15)
    envmean = np.mean(envelope)

    # now high pass the plethysmogram to eliminate baseline
    arb_upper = 10.0
    arb_upperstop = arb_upper * 1.1
    plethfilter.setarb(arb_lowerstop, arb_lower, arb_upper, arb_upperstop)
    filtplethwaveform = plethfilter.apply(Fs, tide_math.corrnormalize(plethwaveform, False, False))
    print('normalizing')
    normpleth = envmean * np.where(envelope > 0.0, filtplethwaveform / envelope, 0.0)

    # return the filtered waveform, the normalized waveform, and the envelope
    return filtplethwaveform, normpleth, envelope


# get the command line parameters
debug = False
dofilter = False
fmrimod = 'none'
histlen = 100
doplot = False
smoothlen = 301
maskthreshpct = 10.0
upsamplefac = 100
destpoints = 32
congridbins = 1.5
gridkernel = 'old'
cardiacfile = None
colnum = 0
colname = None
inputfreq = 32.0
inputstart = 0.0
doglm = False
detrend = True
notchwidth = 0.015
arb_lower = 0.5
arb_upper = 3.0
softvesselfrac = 0.4
infodict = {}
stdfreq = 25.0
nprocs = 1
mklthreads = 1
spatialglmdenoise = True
savecardiacnoise = True
usecongrid = True
forcedhr = None

# start the clock!
timings = [['Start', time.time(), None, None]]

print(
    "***********************************************************************************************************************************")
print("NOTICE:  This program is NOT released yet - it's a work in progress and is nowhere near done.  That's why")
print("there's no documentation or mention in the release notes.  If you want to play with it, be my guest, but be")
print("aware of the following:")
print("    1) Any given version of this program may or may not work, or may work in a way different than ")
print("       a) previous versions, b) what I say it does, c) what I think it does, and d) what you want it to do.")
print(
    "    2) I am intending to write a paper on this, and if you take this code and scoop me, I'll be peeved. That's just rude.")
print("    3) For all I know this program might burn down your house, leave your milk out of the refrigerator, or ")
print("       poison your dog.  USE AT YOUR OWN RISK.")
print(
    "***********************************************************************************************************************************")
print("")

nargs = len(sys.argv)
if nargs < 4:
    usage()
    exit()
fmrifilename = sys.argv[1]
slicetimename = sys.argv[2]
outputroot = sys.argv[3]

infodict['fmrifilename'] = fmrifilename
infodict['slicetimename'] = slicetimename
infodict['outputroot'] = outputroot

tide_util.savecommandline(sys.argv, outputroot)

# now scan for optional arguments
try:
    opts, args = getopt.getopt(sys.argv[4:], "x", ["cardiacfile=",
                                                   "cardiacfreq=",
                                                   "cardiactstep=",
                                                   "cardiacstart=",
                                                   "maxhr=",
                                                   "minhr=",
                                                   "notchwidth=",
                                                   "disablenotch",
                                                   "nodetrend",
                                                   "glm",
                                                   "debug",
                                                   "normalize",
                                                   "demean",
                                                   "outputbins=",
                                                   "gridbins=",
                                                   "gridkernel=",
                                                   "stdfreq=",
                                                   "nprocs=",
                                                   'mklthreads=',
                                                   "smoothlen=",
                                                   "forcehr=",
                                                   "help"])
except getopt.GetoptError as err:
    # print help information and exit:
    print(str(err))  # will print something like "option -x not recognized"
    usage()
    sys.exit(2)

for o, a in opts:
    if o == "-x":
        print('got an x')
    elif o == "--glm":
        doglm = True
        print('will generate and remove aliased voxelwise cardiac regressors')
    elif o == "--disablenotch":
        notchwidth = -1.0
        print('Disabling subharmonic notch filter')
    elif o == "--nodetrend":
        detrend = False
        print('will disable data detrending')
    elif o == "--debug":
        debug = True
        print('extended debugging messages')
    elif o == "--outputbins":
        destpoints = int(a)
        print('will use', destpoints, 'output bins')
    elif o == "--smoothlen":
        smoothlen = int(a)
        smoothlen = smoothlen + (1 - smoothlen % 2)
        print('will set savitsky-golay window to', smoothlen)
    elif o == "--gridbins":
        congridbins = float(a)
        print('will use a convolution gridding kernel of width', congridbins, 'bins')
    elif o == "--gridkernel":
        gridkernel = a
        if gridkernel == 'kaiser':
            print('will use a kaiser-bessel gridding kernel')
        elif gridkernel == 'gauss':
            print('will use a gaussian gridding kernel')
        elif gridkernel == 'old':
            print('falling back to old style gridding')
        else:
            print('illegal gridding kernel specified - aborting')
            sys.exit()
    elif o == "--minhr":
        newval = float(a) / 60.0
        # if newval > arb_lower:
        print('will set bottom of cardiac band to', newval * 60.0, 'BPM from', arb_lower * 60.0, 'BPM')
        arb_lower = newval
    elif o == "--notchwidth":
        notchwidth = float(a) / 100.0
        print('setting notchwidth to', notchwidth * 100.0, '%')
    elif o == "--nprocs":
        nprocs = int(a)
        if nprocs < 1:
            nprocs = tide_multiproc.maxcpus()
        print('will use', nprocs, 'processors for long calculations')
    elif o == '--mklthreads':
            mklthreads = int(a)
            linkchar = '='
            if mklexists:
                print('will use', mklthreads, 'MKL threads for accelerated numpy processing.')
            else:
                print('MKL not present - ignoring --mklthreads')
    elif o == "--stdfreq":
        stdfreq = float(a)
        print('setting common output frequency to', stdfreq)
    elif o == "--maxhr":
        newval = float(a) / 60.0
        # if newval < arb_upper:
        print('will set top of cardiac band to', newval * 60.0, 'BPM from', arb_upper * 60.0, 'BPM')
        arb_upper = newval
    elif o == "--forcehr":
        forcedhr = float(a) / 60.0
        print('force heart rate detector to', forcedhr * 60.0, 'BPM')
    elif o == "--normalize":
        fmrimod = 'norm'
        print('will normalize fmri before gridding')
    elif o == "--demean":
        fmrimod = 'demean'
        print('will demean fmri before gridding')
    elif o == '--cardiacfile':
        inputlist = a.split(':')
        cardiacfile = inputlist[0]
        if len(inputlist) > 1:
            try:
                colnum = int(inputlist[1])
            except IndexError:
                colname = inputlist[1]
        print('Will use cardiac file', cardiacfile)
    elif o == '--cardiacfreq':
        inputfreq = float(a)
        print('Setting cardiac sample frequency to ', inputfreq)
    elif o == '--cardiactstep':
        inputfreq = 1.0 / float(a)
        print('Setting cardiac sample time step to ', float(a))
    elif o == '--cardiacstart':
        inputstart = float(a)
        print('Setting cardiac start time to ', inputstart)
    elif o == "--help":
        usage()
        sys.exit()
    else:
        assert False, "unhandled option: " + o

memfile = open(outputroot + '_memusage.csv', 'w')
tide_util.logmem(None, file=memfile)

# set the number of MKL threads to use
if mklexists:
    mklmaxthreads = mkl.get_max_threads()
    print('mkl max threads =', mklmaxthreads)
    mkl.set_num_threads(mklthreads)

thecardbandfilter = tide_filt.noncausalfilter()
thecardbandfilter.settype('arb')
arb_lowerstop = arb_lower * 0.9
arb_upperstop = arb_upper * 1.1
thecardbandfilter.setarb(arb_lowerstop, arb_lower, arb_upper, arb_upperstop)
infodict['filtermaxbpm'] = arb_upper * 60.0
infodict['filterminbpm'] = arb_lower * 60.0
infodict['notchwidthpct'] = notchwidth * 100.0
timings.append(['Argument parsing done', time.time(), None, None])

# read in the image data
tide_util.logmem('before reading in fmri data', file=memfile)
nim, nim_data, nim_hdr, thedims, thesizes = tide_io.readfromnifti(fmrifilename)
xsize, ysize, numslices, timepoints = tide_io.parseniftidims(thedims)
xdim, ydim, slicethickness, tr = tide_io.parseniftisizes(thesizes)
spaceunit, timeunit = nim_hdr.get_xyzt_units()
if timeunit == 'msec':
    tr /= 1000.0
mrsamplerate = 1.0 / tr
print('tr is', tr, 'seconds, mrsamplerate is', mrsamplerate)
numspatiallocs = int(xsize) * int(ysize) * int(numslices)
infodict['tr'] = tr
infodict['mrsamplerate'] = mrsamplerate
timings.append(['Image data read in', time.time(), None, None])

# remap to space by time
fmri_data = nim_data.reshape((numspatiallocs, timepoints))

# remap to voxel by slice by time
fmri_data_byslice = nim_data.reshape((xsize * ysize, numslices, timepoints))

# make and save a mask of the voxels to process
tide_util.logmem('before mask creation', file=memfile)
mask = np.uint16(tide_stats.makemask(np.mean(fmri_data[:, :], axis=1),
                                     threshpct=maskthreshpct))
theheader = nim_hdr
theheader['dim'][4] = 1
timings.append(['Mask created', time.time(), None, None])
tide_io.savetonifti(mask.reshape((xsize, ysize, numslices)), theheader, thesizes, outputroot + '_mask')
timings.append(['Mask saved', time.time(), None, None])
mask_byslice = mask.reshape((xsize * ysize, numslices))

# get slice times
slicetimes = getslicetimesfromfile(slicetimename)
timings.append(['Slice times determined', time.time(), None, None])

# normalize the input data
print('normalizing voxels...')
normdata = fmri_data * 0.0
demeandata = fmri_data * 0.0
validvoxels = np.where(mask > 0)[0]
starttime = time.time()
means = np.mean(fmri_data[:, :], axis=1).flatten()
demeandata[validvoxels, :] = fmri_data[validvoxels, :] - means[validvoxels, None]
normdata[validvoxels, :] = np.nan_to_num(demeandata[validvoxels, :] / means[validvoxels, None])
print('normalization took', time.time() - starttime, 'seconds')
normdata_byslice = normdata.reshape((xsize * ysize, numslices, timepoints))

# now get an estimate of the cardiac signal
print('estimating cardiac signal from fmri data')
tide_util.logmem('before cardiacfromimage', file=memfile)
cardfromfmri, slicesamplerate, numsteps = cardiacfromimage(normdata_byslice,
                                                           mask_byslice,
                                                           numslices,
                                                           timepoints,
                                                           tr,
                                                           slicetimes,
                                                           thecardbandfilter,
                                                           nprocs=nprocs,
                                                           notchwidth=notchwidth,
                                                           detrend=detrend,
                                                           debug=debug)
timings.append(['Cardiac signal generated from image data', time.time(), None, None])
slicetimeaxis = sp.linspace(0.0, tr * timepoints, num=(timepoints * numsteps), endpoint=False)
tide_io.writevec(cardfromfmri, outputroot + '_cardfromfmri_sliceres.txt')
cardiacwaveform = cardfromfmri
infodict['slicesamplerate'] = slicesamplerate
infodict['numsteps'] = numsteps

# find key components of cardiac waveform
print('extracting harmonic components')
peakfreq_bold, amps_bold, phases_bold = getcardcoeffs(cardiacwaveform, slicesamplerate, smoothlen=smoothlen,
                                                      debug=debug)
infodict['cardiacbpm_frombold'] = np.round(peakfreq_bold * 60.0, 2)
infodict['cardiacfreq_frombold'] = peakfreq_bold
#print('harmonic amplitudes:', amps_bold[0], amps_bold[1], amps_bold[2])
#print('harmonic phases:', phases_bold[0], phases_bold[1], phases_bold[2])
#for i in range(len(amps_bold)):
#    infodict['kalminit_bold_amp' + str(i)] = amps_bold[i]
#    infodict['kalminit_bold_ph' + str(i)] = phases_bold[i]
timings.append(['Cardiac signal from image data analyzed', time.time(), None, None])

tide_io.writevec(
    tide_math.corrnormalize(
        tide_resample.arbresample(cardfromfmri, slicesamplerate, stdfreq, decimate=True, debug=True), False, False),
    outputroot + '_cardfromfmri_' + str(stdfreq) + 'Hz.txt')
timings.append(['Cardiac signal from image data resampled and saved', time.time(), None, None])

# get the cardiac signal from a file, if specified
if cardiacfile is not None:
    tide_util.logmem('before cardiacfromfile', file=memfile)
    print('reading cardiac signal from file')
    infodict['cardiacfromfmri'] = False

    # check file type
    filebase, extension = os.path.splitext(cardiacfile)
    if extension == '.json':
        inputfreq, inputstart, pleth_fullres = tide_io.readcolfrombidstsv(cardiacfile, columnname=colname,
                                                                          columnnum=colnum)
    else:
        pleth_fullres = np.transpose(tide_io.readvecs(cardiacfile))
        print(pleth_fullres.shape)
        if len(pleth_fullres.shape) != 1:
            pleth_fullres = pleth_fullres[:, colnum]
    inputtimeaxis = sp.arange(0.0, (1.0 / inputfreq) * len(pleth_fullres), 1.0 / inputfreq) + inputstart
    if debug:
        print('pleth_fullres: len=', len(pleth_fullres), 'vals=', pleth_fullres)
        print('inputfreq =', inputfreq)
        print('inputstart =', inputstart)
        print('inputtimeaxis: len=', len(inputtimeaxis), 'vals=', inputtimeaxis)
    timings.append(['Cardiac signal from physiology data read in', time.time(), None, None])

    # filter and amplitude correct the waveform to remove gain fluctuations
    cleanpleth_fullres, normpleth_fullres, cardamp = cleanpleth(inputfreq, pleth_fullres)
    tide_io.writevec(pleth_fullres, outputroot + '_rawpleth_native.txt')
    tide_io.writevec(normpleth_fullres, outputroot + '_normpleth_native.txt')
    tide_io.writevec(cleanpleth_fullres, outputroot + '_pleth_native.txt')
    tide_io.writevec(cardamp, outputroot + '_cardenvelopefromfile_native.txt')
    timings.append(['Cardiac signal from physiology data cleaned', time.time(), None, None])

    # resample to slice time resolution and save
    pleth_sliceres = tide_resample.doresample(inputtimeaxis, cleanpleth_fullres, slicetimeaxis, method='cubic',
                                              padlen=0)
    normpleth_sliceres = tide_resample.doresample(inputtimeaxis, normpleth_fullres, slicetimeaxis, method='cubic',
                                                  padlen=0)
    tide_io.writevec(pleth_sliceres, outputroot + '_pleth_sliceres.txt')
    tide_io.writevec(normpleth_sliceres, outputroot + '_normpleth_sliceres.txt')
    timings.append(['Cardiac signal from physiology data resampled to slice resolution and saved', time.time(), None, None])

    # resample to standard resolution and save
    tide_io.writevec(
        tide_math.corrnormalize(
            tide_resample.arbresample(cleanpleth_fullres, inputfreq, stdfreq, decimate=True, debug=True), False, False),
        outputroot + '_pleth_' + str(stdfreq) + 'Hz.txt')
    tide_io.writevec(
        tide_math.corrnormalize(
            tide_resample.arbresample(normpleth_fullres, inputfreq, stdfreq, decimate=True, debug=True), False, False),
        outputroot + '_normpleth_' + str(stdfreq) + 'Hz.txt')
    timings.append(['Cardiac signal from physiology data resampled to standard and saved', time.time(), None, None])

    # find key components of cardiac waveform
    filtpleth = tide_math.corrnormalize(thecardbandfilter.apply(slicesamplerate, pleth_sliceres), False, False)
    peakfreq_file, amps_file, phases_file = getcardcoeffs(filtpleth, slicesamplerate, smoothlen=smoothlen,
                                                          debug=debug)
    timings.append(['Cardiac coefficients calculated from pleth waveform', time.time(), None, None])
    infodict['cardiacbpm_fromphysio'] = np.round(peakfreq_file * 60.0, 2)
    infodict['cardiacfreq_fromphysio'] = peakfreq_file
    #for i in range(len(amps_file)):
    #    infodict['kalminit_file_amp' + str(i)] = amps_file[i]
    #    infodict['kalminit_file_ph' + str(i)] = phases_file[i]
    timings.append(['Cardiac signal from physiology data analyzed', time.time(), None, None])

    timings.append(['Cardiac parameters extracted from physiology data', time.time(), None, None])

    # check the match between the bold and physio cardiac signals
    thexcorr = tide_corr.fastcorrelate(filtpleth, cardfromfmri, usefft=True)
    xcorrlen = len(thexcorr)
    sampletime = 1.0 / slicesamplerate
    xcorr_x = np.r_[0.0:xcorrlen] * sampletime - (xcorrlen * sampletime) / 2.0 + sampletime / 2.0
    # maxdelay = xcorr_x[np.argmax(thexcorr)]
    searchrange = 10.0
    maxindex, maxdelay, maxval, maxsigma, maskval, failreason, peakstart, peakend = tide_fit.findmaxlag_gauss(
        xcorr_x, thexcorr, -searchrange, searchrange, 1000.0,
        refine=True,
        useguess=False,
        fastgauss=False,
        displayplots=False)
    print('Input cardiac waveform delay is', maxdelay, 'relative to fMRI data')
    print('Correlation coefficient between cardiac regressors:', maxval)
    infodict['corrcoeff'] = maxval
    infodict['delay'] = maxdelay
    cardiacwaveform = pleth_sliceres

    if doplot:
        figure()
        plot(slicetimeaxis, pleth_sliceres, 'r', slicetimeaxis, cardfromfmri, 'b')
        show()
    infodict['pleth'] = True
    peakfreq = peakfreq_file
else:
    infodict['pleth'] = False
    peakfreq = peakfreq_bold

#  extract the fundamental
if forcedhr is not None:
    peakfreq = forcedhr
    infodict['forcedhr'] = peakfreq
filthiresfund = tide_math.corrnormalize(getfundamental(cardiacwaveform, slicesamplerate, peakfreq), False, False)
tide_io.writevec(filthiresfund, outputroot + '_cardiacfundamental.txt')

# now calculate the phase waveform
tide_util.logmem('before analytic phase analysis', file=memfile)
instantaneous_phase, amplitude_envelope = phaseanalysis(filthiresfund)
tide_io.writevec(amplitude_envelope, outputroot + '_ampenv.txt')
tide_io.writevec(instantaneous_phase, outputroot + '_instphase_unwrapped.txt')
initialphase = instantaneous_phase[0]
infodict['phi0'] = initialphase
timings.append(['Phase waveform generated', time.time(), None, None])

# account for slice time offests
#offsets = nim_data[:, :, :, 0] * 0.0
offsets_byslice = np.zeros((xsize * ysize, numslices), dtype=np.float64)
for i in range(numslices):
    offsets_byslice[:, i] = slicetimes[i]

# remap to space by time
fmri_offsets = offsets_byslice.reshape(numspatiallocs)

# Make synthetic cardiac files
#gencardiac = tide_math.corrnormalize(
#    amplitude_envelope * cardiacsig(instantaneous_phase, amps=amps_bold, phases=phases_bold), False, False)
#tide_io.writevec(gencardiac, outputroot + '_synthcardiacfromfmri.txt')
#timings.append(['Synthetic cardiac waveform generated', time.time(), None, None])
#
#if infodict['pleth']:
#    gencardiac = tide_math.corrnormalize(
#        amplitude_envelope * cardiacsig(instantaneous_phase, amps=amps_file, phases=phases_file), False, False)
#    tide_io.writevec(gencardiac, outputroot + '_synthcardiacfrompleth.txt')

# save the information file
tide_io.writedict(infodict, outputroot + '_info.txt')

# interpolate the instantaneous phase
upsampledslicetimeaxis = sp.linspace(0.0, tr * timepoints, num=(timepoints * numsteps * upsamplefac), endpoint=False)
interpphase = phasemod(
    tide_resample.doresample(slicetimeaxis, instantaneous_phase, upsampledslicetimeaxis, method='cubic', padlen=0))
tide_io.writevec(interpphase, outputroot + '_interpinstphase.txt')

# calculate RRI
# therri = rrifromphase(upsampledslicetimeaxis, interpphase)

# find the phase values for all timepoints in all slices
phasevals = np.zeros((numslices, timepoints), dtype=np.float64)
for theslice in range(numslices):
    thetimes = sp.linspace(0.0, tr * timepoints, num=timepoints, endpoint=False) + slicetimes[theslice]
    phasevals[theslice, :] = phasemod(
        tide_resample.doresample(slicetimeaxis, instantaneous_phase, thetimes, method='cubic', padlen=0))
    if debug:
        tide_io.writevec(thetimes, outputroot + '_times_' + str(theslice).zfill(2) + '.txt')
        tide_io.writevec(phasevals[theslice, :], outputroot + '_phasevals_' + str(theslice).zfill(2) + '.txt')
timings.append(['Slice phases determined for all timepoints', time.time(), None, None])

# construct a destination array
tide_util.logmem('before making destination arrays', file=memfile)
app = np.zeros((xsize, ysize, numslices, destpoints), dtype=np.float64)
app_byslice = app.reshape((xsize * ysize, numslices, destpoints))
rawapp = np.zeros((xsize, ysize, numslices, destpoints), dtype=np.float64)
rawapp_byslice = rawapp.reshape((xsize * ysize, numslices, destpoints))
weights = np.zeros((xsize, ysize, numslices, destpoints), dtype=np.float64)
weight_byslice = weights.reshape((xsize * ysize, numslices, destpoints))
timings.append(['Output arrays allocated', time.time(), None, None])

# high pass filter to remove trends
imagingtime = tr * timepoints
phasefilter = tide_filt.noncausalfilter()
phasefilter.settype('arb')
arb_lower = 4.0 / imagingtime
arb_upper = 0.5 / tr
arb_lowerstop = arb_lower
arb_upperstop = arb_upper
phasefilter.setarb(arb_lowerstop, arb_lower, arb_upper, arb_upperstop)

outphases = sp.linspace(-np.pi, np.pi - 0.000000000001, num=destpoints, endpoint=True)
outphasestep = outphases[1] - outphases[0]
phasestep = outphases[1] - outphases[0]
congridwidth = congridbins * phasestep

if fmrimod == 'norm':
    fmri_data_byslice = normdata.reshape((xsize * ysize, numslices, timepoints))
elif fmrimod == 'demean':
    fmri_data_byslice = demeandata.reshape((xsize * ysize, numslices, timepoints))
else:
    fmri_data_byslice = nim_data.reshape((xsize * ysize, numslices, timepoints))

# now do the phase projection
timings.append(['Phase projection to image started', time.time(), None, None])
print('starting phase projection')
for theslice in range(numslices):
    print('phase projecting for slice', theslice)
    validlocs = np.where(mask_byslice[:, theslice] > 0)[0]
    indexlist = range(0, len(phasevals[theslice, :]))
    if len(validlocs) > 0:
        if usecongrid:
            for t in range(timepoints):
                if detrend:
                    filteredmr = -tide_fit.detrend(fmri_data_byslice[validlocs, theslice, t], demean=False)
                else:
                    filteredmr = -fmri_data_byslice[validlocs, theslice, t]
                thevals, theweights, theindices = tide_resample.congrid(outphases,
                                                                        phasevals[theslice, t],
                                                                        1.0,
                                                                        congridbins,
                                                                        kernel=gridkernel)
                for i in range(len(theindices)):
                    weight_byslice[validlocs, theslice, theindices[i]] += theweights[i]
                    rawapp_byslice[validlocs, theslice, theindices[i]] += theweights[i] * filteredmr
            for d in range(destpoints):
                if weight_byslice[validlocs[0], theslice, d] == 0.0:
                    weight_byslice[validlocs, theslice, d] = 1.0
            rawapp_byslice[validlocs, theslice, :] = \
                np.nan_to_num(rawapp_byslice[validlocs, theslice, :] / weight_byslice[validlocs, theslice, :])
        else:
            destinds = ((phasevals[theslice, :] + np.pi + 0.5 * outphasestep) // outphasestep).astype(int)
            for t in range(timepoints):
                if detrend:
                    filteredmr = -tide_fit.detrend(fmri_data_byslice[validlocs, theslice, t], demean=False)
                else:
                    filteredmr = -fmri_data_byslice[validlocs, theslice, t]
                weight_byslice[validlocs, theslice, destinds[t]] += 1
                rawapp_byslice[validlocs, theslice, destinds[t]] += filteredmr
            rawapp_byslice[validlocs, theslice, :] = \
                np.nan_to_num(rawapp_byslice[validlocs, theslice, :] / weight_byslice[validlocs, theslice, :])
    else:
        rawapp_byslice[:, theslice, :]

    slicemin = np.min(rawapp_byslice[validlocs, theslice, :], axis=1).reshape((-1, 1))
    app_byslice[validlocs, theslice, :] = rawapp_byslice[validlocs, theslice, :] - slicemin
timings.append(['Phase projection to image completed', time.time(), None, None])
print('phase projection done')

# save the analytic phase projection image
theheader = nim_hdr
theheader['dim'][4] = destpoints
theheader['toffset'] = -np.pi
theheader['pixdim'][4] = 2.0 * np.pi / destpoints
tide_io.savetonifti(app, theheader, thesizes, outputroot + '_app')
tide_io.savetonifti(rawapp, theheader, thesizes, outputroot + '_rawapp')
# tide_io.savetonifti(weights, theheader, thesizes, outputroot + '_weights')
timings.append(['Phase projected data saved', time.time(), None, None])

# make and save a voxel intensity histogram
app2d = app.reshape((numspatiallocs, destpoints))
validlocs = np.where(mask > 0)[0]
histinput = app2d[validlocs, :].reshape((len(validlocs), destpoints))
tide_stats.makeandsavehistogram(histinput, histlen, 0, outputroot + '_histogram')

# make find vessel threshholds 
tide_util.logmem('before making vessel masks', file=memfile)
hardvesselthresh = tide_stats.getfracvals(np.max(histinput, axis=1), [0.98])[0] / 2.0
softvesselthresh = softvesselfrac * hardvesselthresh
print('hard, soft vessel threshholds set to', hardvesselthresh, softvesselthresh)

# save a vessel masked version of app
vesselmask = np.where(np.max(app, axis=3) > softvesselthresh, 1, 0)
maskedapp2d = app2d + 0.0
maskedapp2d[np.where(vesselmask.reshape(numspatiallocs) == 0)[0], :] = 0.0
tide_io.savetonifti(maskedapp2d.reshape((xsize, ysize, numslices, destpoints)), theheader, thesizes,
                    outputroot + '_maskedapp')
del maskedapp2d
timings.append(['Vessel masked phase projected data saved', time.time(), None, None])

# save multiple versions of the hard vessel mask
vesselmask = np.where(np.max(app, axis=3) > hardvesselthresh, 1, 0)
minphase = np.argmin(app, axis=3) * 2.0 * np.pi / destpoints - np.pi
maxphase = np.argmax(app, axis=3) * 2.0 * np.pi / destpoints - np.pi
risediff = (maxphase - minphase) * vesselmask
arteries = np.where(risediff < 0, 1, 0)
veins = np.where(risediff > 0, 1, 0)
theheader = nim_hdr
theheader['dim'][4] = 1
tide_io.savetonifti(vesselmask, theheader, thesizes, outputroot + '_vesselmask')
tide_io.savetonifti(minphase, theheader, thesizes, outputroot + '_minphase')
tide_io.savetonifti(maxphase, theheader, thesizes, outputroot + '_maxphase')
tide_io.savetonifti(arteries, theheader, thesizes, outputroot + '_arteries')
tide_io.savetonifti(veins, theheader, thesizes, outputroot + '_veins')
timings.append(['Masks saved', time.time(), None, None])

# now generate aliased cardiac signals and regress them out of the data
if doglm:
    # generate the signals
    timings.append(['Cardiac signal regression started', time.time(), None, None])
    tide_util.logmem('before cardiac regression', file=memfile)
    print('generating cardiac regressors')
    cardiacnoise = fmri_data * 0.0
    cardiacnoise_byslice = cardiacnoise.reshape((xsize * ysize, numslices, timepoints))
    for theslice in range(numslices):
        print('calculating cardiac noise for slice', theslice)
        validlocs = np.where(mask_byslice[:, theslice] > 0)[0]
        for t in range(timepoints):
            phaseindex = int(np.round((phasevals[theslice, t] - outphases[0]) / phasestep, 0))
            cardiacnoise_byslice[validlocs, theslice, t] = rawapp_byslice[validlocs, theslice, phaseindex]
    theheader = nim_hdr
    timings.append(['Cardiac signal generated', time.time(), None, None])
    if savecardiacnoise:
        tide_io.savetonifti(cardiacnoise.reshape((xsize, ysize, numslices, timepoints)), theheader, thesizes, outputroot + '_cardiacnoise')
        timings.append(['Cardiac signal saved', time.time(), None, None])

    # now remove them
    tide_util.logmem('before cardiac removal', file=memfile)
    print('removing cardiac signal with GLM')
    nprocs = 4
    filtereddata = 0.0 * fmri_data
    datatoremove = 0.0 * fmri_data
    validlocs = np.where(mask > 0)[0]
    numvalidspatiallocs = len(validlocs)
    threshval = 0.0
    if spatialglmdenoise:
        meanvals = np.zeros((timepoints), dtype=np.float64)
        rvals = np.zeros((timepoints), dtype=np.float64)
        r2vals = np.zeros((timepoints), dtype=np.float64)
        fitcoffs = np.zeros((timepoints), dtype=np.float64)
        fitNorm = np.zeros((timepoints), dtype=np.float64)
        print('running glm on', timepoints, 'timepoints')
        tide_glmpass.glmpass(timepoints,
                             fmri_data[validlocs, :],
                             threshval,
                             cardiacnoise[validlocs, :],
                             meanvals,
                             rvals,
                             r2vals,
                             fitcoffs,
                             fitNorm,
                             datatoremove[validlocs, :],
                             filtereddata[validlocs, :],
                             reportstep=(timepoints // 100),
                             mp_chunksize=100,
                             procbyvoxel=False,
                             nprocs=nprocs
                             )
        timings.append(['Cardiac signal regression finished', time.time(), None, None])
        tide_io.writevec(fitcoffs, outputroot + '_fitcoff.txt')
        tide_io.writevec(meanvals, outputroot + '_fitmean.txt')
        tide_io.writevec(rvals, outputroot + '_fitR.txt')
    else:
        meanvals = np.zeros((numspatiallocs), dtype=np.float64)
        rvals = np.zeros((numspatiallocs), dtype=np.float64)
        r2vals = np.zeros((numspatiallocs), dtype=np.float64)
        fitcoffs = np.zeros((numspatiallocs), dtype=np.float64)
        fitNorm = np.zeros((numspatiallocs), dtype=np.float64)
        print('running glm on', numvalidspatiallocs, 'voxels')
        tide_glmpass.glmpass(numvalidspatiallocs,
                             fmri_data[validlocs, :],
                             threshval,
                             cardiacnoise[validlocs, :],
                             meanvals[validlocs],
                             rvals[validlocs],
                             r2vals[validlocs],
                             fitcoffs[validlocs],
                             fitNorm[validlocs],
                             datatoremove[validlocs, :],
                             filtereddata[validlocs, :],
                             procbyvoxel=True,
                             nprocs=nprocs
                             )
        timings.append(['Cardiac signal regression finished', time.time(), None, None])
        theheader = nim_hdr
        theheader['dim'][4] = 1
        tide_io.savetonifti(fitcoffs.reshape((xsize, ysize, numslices)), theheader, thesizes,
                            outputroot + '_fitamp')
        tide_io.savetonifti(meanvals.reshape((xsize, ysize, numslices)), theheader, thesizes,
                            outputroot + '_fitamp')
        tide_io.savetonifti(rvals.reshape((xsize, ysize, numslices)), theheader, thesizes,
                            outputroot + '_fitR')

    theheader = nim_hdr
    tide_io.savetonifti(filtereddata.reshape((xsize, ysize, numslices, timepoints)), theheader, thesizes,
                        outputroot + '_filtereddata')
    tide_io.savetonifti(datatoremove.reshape((xsize, ysize, numslices, timepoints)), theheader, thesizes,
                        outputroot + '_datatoremove')
    timings.append(['Cardiac signal regression files written', time.time(), None, None])

timings.append(['Done', time.time(), None, None])

# Process and save timing information
nodeline = 'Processed on ' + platform.node()
tide_util.proctiminginfo(timings, outputfile=outputroot + '_runtimings.txt', extraheader=nodeline)

tide_util.logmem('final', file=memfile)
